<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bfbrain.Data_Manager &#8212; bfbrain 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for bfbrain.Data_Manager</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A module containing the DataManager class, which handles the generation </span>
<span class="sd">and labelling of training and validation data for the BFBLearner class.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">bfbrain.Jax_Oracle</span> <span class="kn">import</span> <span class="n">label_func</span><span class="p">,</span> <span class="n">test_labeller</span>
<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sym</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">lambdify</span><span class="p">,</span> <span class="n">re</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">default_rng</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">SeedSequence</span>
<span class="kn">from</span> <span class="nn">bfbrain.Hypersphere_Formulas</span> <span class="kn">import</span> <span class="n">rand_nsphere</span><span class="p">,</span> <span class="n">convert_from_polar_sym</span>

<div class="viewcode-block" id="labeller_wrapper">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.labeller_wrapper">[docs]</a>
<span class="k">class</span> <span class="nc">labeller_wrapper</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for the labelling function which serves as the active </span>
<span class="sd">    learning oracle.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        A numeric function for the potential. This is a numeric function </span>
<span class="sd">        generated by the class DataManager in its init method. It will </span>
<span class="sd">        take numeric arrays (of a format depending on the DataManager </span>
<span class="sd">        class) representing a scalar vev and a set of quartic potential </span>
<span class="sd">        coefficients and return the numerical value of the quartic part </span>
<span class="sd">        of the potential function and its gradient with respect to the vev.</span>

<span class="sd">    phi_len : int</span>
<span class="sd">        The number of real parameters necessary to uniquely specify a vev </span>
<span class="sd">        in the model.</span>

<span class="sd">    lam_len : int</span>
<span class="sd">        The number of independent real quartic coefficients in the model.</span>

<span class="sd">    rng : np.random.Generator</span>
<span class="sd">        The random number generator which governs any random processes </span>
<span class="sd">        that the oracle may use.</span>

<span class="sd">    polar : bool</span>
<span class="sd">        If True, then the analysis of the potential will be conducted with </span>
<span class="sd">        a polar coordinate parameterization of the vev parameters. </span>
<span class="sd">        If False, then Cartesian coordinates will be used, albeit with the </span>
<span class="sd">        vev parameters restricted to a phi_len-dimensional unit </span>
<span class="sd">        hypersphere.</span>

<span class="sd">    label_fn : callable, optional.</span>
<span class="sd">        A function that takes a 2-D NumPy array of quartic coefficients </span>
<span class="sd">        and returns a list of Boolean labels for them. This is for </span>
<span class="sd">        implementing customized oracle functions. Must have the signature </span>
<span class="sd">        (func: Callable, phi_len: int, polar: bool, rng: NumpyGenerator, lam: np.array(np.float, np.float), **kwargs) -&gt; np.array(bool)</span>
<span class="sd">        If this argument is not specified, the default oracle </span>
<span class="sd">        BFBrain.Jax_Oracle.label_func is used.</span>

<span class="sd">    label_check : callable, optional</span>
<span class="sd">        A function that can be used to test the reliability of a custom </span>
<span class="sd">        oracle given by label_fn, or if label_fn is None, the default </span>
<span class="sd">        oracle BFBrain.Jax_Oracle.label_func. Must have the same signature </span>
<span class="sd">        as label_fn, up to additional keyword arguments. If this argument </span>
<span class="sd">        is not specified, the a tester for the default oracle is used: </span>
<span class="sd">        BFBrain.Jax_Oracle.test_labeller</span>

<span class="sd">    **label_kwargs : dict, default=dict(niter = 250)</span>
<span class="sd">        A dictionary of additional keyword arguments needed for the </span>
<span class="sd">        labelling function label_func. The default values are applicable </span>
<span class="sd">        for the default oracle function, BFBrain.Jax_Oracle.label_func</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">lam_len</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">label_fn</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label_check</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">niter</span> <span class="o">=</span> <span class="mi">250</span><span class="p">)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_len</span> <span class="o">=</span> <span class="n">phi_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_len</span> <span class="o">=</span> <span class="n">lam_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">rng</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polar</span> <span class="o">=</span> <span class="n">polar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_kwargs</span> <span class="o">=</span> <span class="n">label_kwargs</span>
        <span class="k">if</span><span class="p">(</span><span class="n">label_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_fn</span> <span class="o">=</span> <span class="n">label_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_fn</span> <span class="o">=</span> <span class="n">label_fn</span>
        <span class="k">if</span><span class="p">(</span><span class="n">label_check</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_check</span> <span class="o">=</span> <span class="n">test_labeller</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_check</span> <span class="o">=</span> <span class="n">label_check</span>

<div class="viewcode-block" id="labeller_wrapper.do_labelling">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.labeller_wrapper.do_labelling">[docs]</a>
    <span class="k">def</span> <span class="nf">do_labelling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">label_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs labelling using the class&#39;s oracle function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lam : np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array of sets of quartic potential coefficients.</span>

<span class="sd">        label_kwargs : dict, optional</span>
<span class="sd">            An optional alternative set of oracle keyword arguments. If </span>
<span class="sd">            not specified, the class instance&#39;s label_kwargs</span>
<span class="sd">            attribute is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array(bool)</span>
<span class="sd">            A 1-D NumPy array of labels for lam, for which points that </span>
<span class="sd">            are bounded from below are labelled &quot;True&quot; and points which </span>
<span class="sd">            are not are labelled &quot;False&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="o">**</span><span class="n">label_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">label_kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="labeller_wrapper.check_labeller">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.labeller_wrapper.check_labeller">[docs]</a>
    <span class="k">def</span> <span class="nf">check_labeller</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="o">**</span><span class="n">tester_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tests the reliability of the labelling-- calls </span>
<span class="sd">        self.label_check. Depending on the methodology of label_func, </span>
<span class="sd">        this function may or may not be useful. For example, a rigorous </span>
<span class="sd">        computation of boundedness-from-below based on resultants would </span>
<span class="sd">        not require any consistency or reliability checks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lam : np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array of sets of quartic potential coefficients.</span>

<span class="sd">        tester_kwargs : dict</span>
<span class="sd">            A set of keyword arguments for self.label_check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Will return what self.label_check returns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_kwargs</span> <span class="o">|</span> <span class="n">tester_kwargs</span><span class="p">))</span></div>
</div>


<div class="viewcode-block" id="np_data">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.np_data">[docs]</a>
<span class="k">class</span> <span class="nc">np_data</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Holds labelled sets of quartic coefficients in CPU memory in a </span>
<span class="sd">    format that&#39;s easy to save, load, and manipulate.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pos : np.array(np.float32, np.float32)</span>
<span class="sd">        A 2-D NumPy array of sets of quartic coefficients in the </span>
<span class="sd">        potential, which the labeller has determined are </span>
<span class="sd">        bounded-from-below.</span>

<span class="sd">    neg : np.array(np.float32, np.float32)</span>
<span class="sd">        A 2-D NumPy array of sets of quartic coefficients in the </span>
<span class="sd">        potential, which the labeller has determined are NOT </span>
<span class="sd">        bounded-from-below.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neg</span> <span class="o">=</span> <span class="n">neg</span>

<div class="viewcode-block" id="np_data.from_file">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.np_data.from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A constructor for loading an np_data object from a .npz file </span>
<span class="sd">        (see NumPy documentation), likely created in a previous BFBrain </span>
<span class="sd">        analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            A string with a file name. &#39;.npz&#39; is appended to the end of </span>
<span class="sd">            the string, and should not be included in path.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np_data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npz_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="o">+</span><span class="s1">&#39;.npz&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">npz_data</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]),</span> <span class="n">neg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">npz_data</span><span class="p">[</span><span class="s1">&#39;neg&#39;</span><span class="p">]))</span></div>

    
<div class="viewcode-block" id="np_data.save_data">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.np_data.save_data">[docs]</a>
    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves the data object to the filepath specified as an npz </span>
<span class="sd">        object (see NumPy documentation)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            A string with a file name. If .npz is not at the end of the </span>
<span class="sd">            string, it is appended to it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="np_data.append_data">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.np_data.append_data">[docs]</a>
    <span class="k">def</span> <span class="nf">append_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given another np_data object, appends its data to this </span>
<span class="sd">        object in place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_data: np_data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">new_data</span><span class="o">.</span><span class="n">pos</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">neg</span><span class="p">,</span> <span class="n">new_data</span><span class="o">.</span><span class="n">neg</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="np_data.n_elements">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.np_data.n_elements">[docs]</a>
    <span class="k">def</span> <span class="nf">n_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the total number of sets of quartic coefficients in </span>
<span class="sd">        the object (both bounded-from-below and not bounded-from-below)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The total number of sets of quartic coefficients in the </span>
<span class="sd">            np_data object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span></div>
</div>

        
<div class="viewcode-block" id="DataManager">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager">[docs]</a>
<span class="k">class</span> <span class="nc">DataManager</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class containing methods which process and generate data. </span>
<span class="sd">    Note that this class contains all the random number generation that&#39;s </span>
<span class="sd">    not specifically associated with the neural network and its optimizer.</span>
<span class="sd">    Generally one should use the &#39;from_seed&#39; or &#39;from_file&#39; constructor </span>
<span class="sd">    rather than constructing from the base initialization method.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    phi_len : int</span>
<span class="sd">        The number of independent real parameters needed to uniquely </span>
<span class="sd">        specify a vev in the model.</span>

<span class="sd">    lam_len : int</span>
<span class="sd">        The number of independent real quartic potential coefficients </span>
<span class="sd">        in the model.</span>

<span class="sd">    rng : list of numpy.random.Generator</span>
<span class="sd">        A list of NumPy random number generators which control all the </span>
<span class="sd">        random generation related to the generation and labelling of data. </span>
<span class="sd">        In total there are 6 random number generators, each differently </span>
<span class="sd">        seeded using NumPy&#39;s SeedSequence.spawn method. Each random number </span>
<span class="sd">        generator is used only for one specific task: Generating training </span>
<span class="sd">        data, generating validation data, generating random points in the </span>
<span class="sd">        vicinity of other points (two rng&#39;s are used here, one for </span>
<span class="sd">        rotation direction and the other for rotation angle), </span>
<span class="sd">        doing random number generation associated with labelling, and </span>
<span class="sd">        shuffling data for training.</span>

<span class="sd">    polar : bool</span>
<span class="sd">        If true, the potential is analyzed with the vev coordinates </span>
<span class="sd">        converted to a polar form. If false, they are analyzed in their </span>
<span class="sd">        Cartesian form.</span>

<span class="sd">    sym_expr : SymPy expression</span>
<span class="sd">        Represents the potential function in a form that is both picklable </span>
<span class="sd">        and can easily be used to generate the gradient symbolically.</span>

<span class="sd">    sym_grad_expr : SymPy expression</span>
<span class="sd">        Represents the gradient of the potential function in a form that </span>
<span class="sd">        is both picklable and can easily be used to generate the gradient </span>
<span class="sd">        symbolically.</span>

<span class="sd">    phisym_var : sympy.Array</span>
<span class="sd">        The symbols representing the quartic potential coefficients in </span>
<span class="sd">        sym_expr.</span>

<span class="sd">    lamsym : sympy.Array</span>
<span class="sd">        The symbols representing the quartic potential coefficients in </span>
<span class="sd">        sym_expr.</span>

<span class="sd">    lambdify_mode : {&#39;jax&#39;, &#39;numpy&#39;, &#39;scipy&#39;, &#39;math&#39;, &#39;mpmath&#39;, &#39;numexpr&#39;, &#39;sympy&#39;, &#39;tensorflow&#39;}</span>
<span class="sd">        Passed directly as the argument &quot;modules&quot; in sympy.lambdify, the </span>
<span class="sd">        function used to generate numerical functions from the symbolic </span>
<span class="sd">        expression for the scalar potential. Default value is &#39;jax&#39;, </span>
<span class="sd">        consistent with the default oracle function, </span>
<span class="sd">        BFBrain.Jax_Oracle.label_func</span>

<span class="sd">    label_fn : callable, optional</span>
<span class="sd">        A function that takes a 2-D NumPy array of quartic coefficients </span>
<span class="sd">        and returns a list of Boolean labels for them. This is for </span>
<span class="sd">        implementing customized oracle functions. Must have the signature </span>
<span class="sd">        (func: Callable, phi_len: int, polar: bool, rng: NumpyGenerator, lam: np.array(np.float, np.float), **kwargs) -&gt; np.array(bool)</span>
<span class="sd">        If this argument is not specified, the default oracle </span>
<span class="sd">        BFBrain.Jax_Oracle.label_func is used.</span>

<span class="sd">    label_check : callable, optional</span>
<span class="sd">        A function that can be used to test the reliability of a custom </span>
<span class="sd">        oracle given by label_fn, or if label_fn is None, the default </span>
<span class="sd">        oracle BFBrain.Jax_Oracle.label_func. Must have the same signature </span>
<span class="sd">        as label_fn, up to additional keyword arguments. If this argument </span>
<span class="sd">        is not specified, the a tester for the default oracle is used: </span>
<span class="sd">        BFBrain.Jax_Oracle.test_labeller</span>

<span class="sd">    **label_kwargs : dict, optional</span>
<span class="sd">        A dictionary of additional keyword arguments needed for the </span>
<span class="sd">        labelling function label_func.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">lam_len</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">sym_expr</span><span class="p">,</span> <span class="n">sym_grad_expr</span><span class="p">,</span> <span class="n">phisym_var</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">,</span> <span class="n">lambdify_mode</span> <span class="o">=</span> <span class="s1">&#39;jax&#39;</span><span class="p">,</span> <span class="n">label_fn</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label_check</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">label_kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_len</span> <span class="o">=</span> <span class="n">phi_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_len</span> <span class="o">=</span> <span class="n">lam_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">rng</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polar</span> <span class="o">=</span> <span class="n">polar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sym_expr</span> <span class="o">=</span> <span class="n">sym_expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sym_grad_expr</span> <span class="o">=</span> <span class="n">sym_grad_expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phisym_var</span> <span class="o">=</span> <span class="n">phisym_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lamsym</span> <span class="o">=</span> <span class="n">lamsym</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span> <span class="o">=</span> <span class="n">lambdify_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_fn</span> <span class="o">=</span> <span class="n">label_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_check</span> <span class="o">=</span> <span class="n">label_check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_kwargs</span> <span class="o">=</span> <span class="n">label_kwargs</span>

        <span class="c1">#Now create numerical functions for the value and gradient of the </span>
        <span class="c1"># quartic part of the potential from the symbolic function:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">lambdify_mode</span> <span class="o">==</span> <span class="s1">&#39;jax&#39;</span><span class="p">):</span>
            <span class="n">num_func</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">lambdify</span><span class="p">([</span><span class="n">phisym_var</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">],</span> <span class="n">sym_expr</span><span class="p">,</span> <span class="n">lambdify_mode</span><span class="p">))</span>
            <span class="n">num_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">lambdify</span><span class="p">([</span><span class="n">phisym_var</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">],</span> <span class="n">sym_grad_expr</span><span class="p">,</span> <span class="n">lambdify_mode</span><span class="p">))</span>
        <span class="k">elif</span><span class="p">(</span><span class="n">lambdify_mode</span> <span class="o">==</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">):</span>
            <span class="n">num_func</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">lambdify</span><span class="p">([</span><span class="n">phisym_var</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">],</span> <span class="n">sym_expr</span><span class="p">,</span> <span class="n">lambdify_mode</span><span class="p">))</span>
            <span class="n">num_grad</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">lambdify</span><span class="p">([</span><span class="n">phisym_var</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">],</span> <span class="n">sym_grad_expr</span><span class="p">,</span> <span class="n">lambdify_mode</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_func</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">phisym_var</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">],</span> <span class="n">sym_expr</span><span class="p">,</span> <span class="n">lambdify_mode</span><span class="p">)</span>
            <span class="n">num_grad</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">phisym_var</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">],</span> <span class="n">sym_grad_expr</span><span class="p">,</span> <span class="n">lambdify_mode</span><span class="p">)</span>

        <span class="k">if</span><span class="p">(</span><span class="n">lambdify_mode</span> <span class="o">==</span> <span class="s1">&#39;jax&#39;</span><span class="p">):</span>
            <span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
            <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">num_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">),</span> <span class="n">num_grad</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">)</span>
        <span class="k">elif</span><span class="p">(</span><span class="n">lambdify_mode</span> <span class="o">==</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">):</span>
            <span class="nd">@tf</span><span class="o">.</span><span class="n">function</span>
            <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">num_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">num_grad</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">num_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">),</span> <span class="n">num_grad</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">)</span>   
        
        <span class="c1">#Initialize the labeller.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeller</span> <span class="o">=</span> <span class="n">labeller_wrapper</span><span class="p">(</span><span class="n">min_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_fn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_check</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_kwargs</span><span class="p">)</span>
    

<div class="viewcode-block" id="DataManager.from_func">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.from_func">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_func</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sym_func</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">lam_len</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">polar</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lambdify_mode</span> <span class="o">=</span> <span class="s1">&#39;jax&#39;</span><span class="p">,</span> <span class="n">label_fn</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label_check</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">label_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Preferred constructor for initializing DataManager.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sym_func : SymPy function.</span>
<span class="sd">            A SymPy function that expresses the quartic part of the </span>
<span class="sd">            potential. Must have the signature </span>
<span class="sd">            (sympy.Array, sympy.Array) -&gt; sympy.Expr, where the first </span>
<span class="sd">            sympy.Array object corresponds to the vev configuration</span>
<span class="sd">            and the second corresponds to the quartic coefficients </span>
<span class="sd">            in the potential.</span>

<span class="sd">        phi_len : int</span>
<span class="sd">            The number of real parameters needed to uniquely specify the </span>
<span class="sd">            vev in the model.</span>

<span class="sd">        lam_len : int</span>
<span class="sd">            The number of independent real quartic coupling coefficients </span>
<span class="sd">            in the model&#39;s potential function.</span>

<span class="sd">        seed : int, optional</span>
<span class="sd">            A random number seed. Used to spawn a sequence of random </span>
<span class="sd">            generators with SeedSequence.</span>

<span class="sd">        polar : bool, default=False</span>
<span class="sd">            If true, the potential is analyzed with the vev coordinates </span>
<span class="sd">            converted to a polar form. If false, they are analyzed in </span>
<span class="sd">            their Cartesian form.</span>

<span class="sd">        lambdify_mode : {&#39;jax&#39;, &#39;numpy&#39;, &#39;scipy&#39;, &#39;math&#39;, &#39;mpmath&#39;, &#39;numexpr&#39;, &#39;sympy&#39;, &#39;tensorflow&#39;}</span>
<span class="sd">            The &quot;module&quot; input to sympy.lambdify, used to extract </span>
<span class="sd">            numerical expressions from the symbolic SymPy function. </span>
<span class="sd">            See SymPy documentation for details.</span>

<span class="sd">        label_fn : callable, optional</span>
<span class="sd">            A function that takes a 2-D NumPy array of quartic </span>
<span class="sd">            coefficients and returns a list of Boolean labels for them. </span>
<span class="sd">            This is for implementing customized oracle functions. Must have the signature </span>
<span class="sd">            (func: Callable, phi_len: int, polar: bool, rng: numpy.random.Generator, lam: np.array(np.float, np.float), **kwargs) -&gt; np.array(bool)</span>
<span class="sd">            If this argument is not specified, the default oracle </span>
<span class="sd">            BFBrain.Jax_Oracle.label_func is used.</span>

<span class="sd">        label_check : callable, optional</span>
<span class="sd">            A function that can be used to test the reliability of a </span>
<span class="sd">            custom oracle given by label_fn, or if label_fn is None, the </span>
<span class="sd">            default oracle BFBrain.Jax_Oracle.label_func. Must have the </span>
<span class="sd">            same signature as label_fn, up to additional keyword arguments.</span>
<span class="sd">            If this argument is not specified, the a tester for the </span>
<span class="sd">            default oracle is used: BFBrain.Jax_Oracle.test_labeller</span>

<span class="sd">        **label_kwargs : dict, optional</span>
<span class="sd">            A dictionary of additional keyword arguments needed for the </span>
<span class="sd">            labelling function label_func.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Create the symbols for some symbolic manipulation:</span>
        <span class="n">phisym</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;phi:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">phi_len</span><span class="p">),</span> <span class="n">real</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">lamsym</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;lambda:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">lam_len</span><span class="p">),</span> <span class="n">real</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>

        <span class="c1">#Initialize the random number generators:</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="n">SeedSequence</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="p">[</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>

        <span class="c1">#Now create a simplified symbolic expression for the quartic part of the potential from the symbolic function:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">polar</span><span class="p">):</span>
            <span class="n">phisym_pol</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;theta:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">phi_len</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">real</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
            <span class="n">sym_expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">sym_func</span><span class="p">(</span><span class="n">phisym</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">phisym</span><span class="p">,</span> <span class="n">convert_from_polar_sym</span><span class="p">(</span><span class="n">phisym_pol</span><span class="p">)))</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lamsym</span><span class="p">)))</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lamsym</span><span class="p">)</span>
            <span class="n">sym_grad_expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_expr</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phisym_pol</span><span class="p">)</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">phi_len</span><span class="p">,</span> <span class="n">lam_len</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">sym_expr</span><span class="p">,</span> <span class="n">sym_grad_expr</span><span class="p">,</span> <span class="n">phisym_pol</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">,</span> <span class="n">lambdify_mode</span><span class="p">,</span> <span class="n">label_fn</span><span class="p">,</span> <span class="n">label_check</span><span class="p">,</span> <span class="o">**</span><span class="n">label_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sym_expr</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">sym_func</span><span class="p">(</span><span class="n">phisym</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">))</span>
            <span class="n">sym_grad_expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">sym_expr</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phisym</span><span class="p">)</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">phi_len</span><span class="p">,</span> <span class="n">lam_len</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">sym_expr</span><span class="p">,</span> <span class="n">sym_grad_expr</span><span class="p">,</span> <span class="n">phisym</span><span class="p">,</span> <span class="n">lamsym</span><span class="p">,</span> <span class="n">lambdify_mode</span><span class="p">,</span> <span class="n">label_fn</span><span class="p">,</span> <span class="n">label_check</span><span class="p">,</span> <span class="o">**</span><span class="n">label_kwargs</span><span class="p">)</span></div>

    
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify pickle&#39;s saving of this class to avoid unpicklable </span>
<span class="sd">        objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;labeller&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state</span>
    
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify pickle&#39;s loading of this class to reconstruct </span>
<span class="sd">        unpicklable objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1">#Now create numerical functions for the value and gradient of the </span>
        <span class="c1"># quartic part of the potential from the symbolic function:</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span> <span class="o">==</span> <span class="s1">&#39;jax&#39;</span><span class="p">):</span>
            <span class="n">num_func</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">lambdify</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phisym_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lamsym</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span><span class="p">))</span>
            <span class="n">num_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">lambdify</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phisym_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lamsym</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_grad_expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span><span class="p">))</span>
        <span class="k">elif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span> <span class="o">==</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">):</span>
            <span class="n">num_func</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">lambdify</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phisym_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lamsym</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span><span class="p">))</span>
            <span class="n">num_grad</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">lambdify</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phisym_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lamsym</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_grad_expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_func</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phisym_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lamsym</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span><span class="p">)</span>
            <span class="n">num_grad</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phisym_var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lamsym</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sym_grad_expr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span><span class="p">)</span>
 
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span> <span class="o">==</span> <span class="s1">&#39;jax&#39;</span><span class="p">):</span>
            <span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
            <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">num_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">),</span> <span class="n">num_grad</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">)</span>
        <span class="k">elif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambdify_mode</span> <span class="o">==</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">):</span>
            <span class="nd">@tf</span><span class="o">.</span><span class="n">function</span>
            <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">num_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">num_grad</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">num_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">),</span> <span class="n">num_grad</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">lam</span><span class="p">)</span>   
        
        <span class="c1">#Initialize the labeller.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labeller</span> <span class="o">=</span> <span class="n">labeller_wrapper</span><span class="p">(</span><span class="n">min_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_fn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_check</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_kwargs</span><span class="p">)</span>
    
<div class="viewcode-block" id="DataManager.create_random_lambdas">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.create_random_lambdas">[docs]</a>
    <span class="k">def</span> <span class="nf">create_random_lambdas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlams</span><span class="p">,</span> <span class="n">validation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a list of random sets of quartic potential coefficients </span>
<span class="sd">        (but don&#39;t label them yet). Use independent uncorrelated rng&#39;s for </span>
<span class="sd">        the generation of a validation and training set. Notice that these </span>
<span class="sd">        lambdas are Cartesian coordinates that uniformly sample the </span>
<span class="sd">        unit hypersphere.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nlams : int</span>
<span class="sd">            The number of sets of quartic coefficients to generate </span>
<span class="sd">            randomly.</span>

<span class="sd">        validation: bool, default=False</span>
<span class="sd">            A flag denoting which random number generator to use, </span>
<span class="sd">            ensuring independently-generated validation and training sets. </span>
<span class="sd">            If True, use the random number generator for the </span>
<span class="sd">            validation set, while if False, use the random number </span>
<span class="sd">            generator for the training set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array representing a list of sets of quartic </span>
<span class="sd">            coefficients for the potential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">validation</span><span class="p">):</span>
            <span class="n">rand_lams</span> <span class="o">=</span> <span class="n">rand_nsphere</span><span class="p">(</span><span class="n">nlams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rand_lams</span> <span class="o">=</span> <span class="n">rand_nsphere</span><span class="p">(</span><span class="n">nlams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rand_lams</span></div>

    
<div class="viewcode-block" id="DataManager.check_labeller">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.check_labeller">[docs]</a>
    <span class="k">def</span> <span class="nf">check_labeller</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlams</span><span class="p">,</span> <span class="o">**</span><span class="n">tester_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A wrapper for calling the labeller&#39;s check_labeller function. </span>
<span class="sd">        Generates sample quartic coefficients randomly before running </span>
<span class="sd">        labeller.check_labeller on them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nlams : int</span>
<span class="sd">            The number of sets of quartic coefficients to randomly </span>
<span class="sd">            generate for testing the labeller function&#39;s consistency.</span>

<span class="sd">        tester_kwargs : dict</span>
<span class="sd">            Additional keyword arguments required by the check_labeller </span>
<span class="sd">            function. If the default oracle and tester are used, possible </span>
<span class="sd">            keyword arguments are niter_step, count_success, max_iter, </span>
<span class="sd">            verbose. See BFBrain.Jax_Oracle.test_labeller for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Same type as labeller.check_labeller, which may be a </span>
<span class="sd">            user-written function. If the default oracle and tester are </span>
<span class="sd">            used, this function will be BFBrain.Jax_Oracle.test_labeller.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_random_lambdas</span><span class="p">(</span><span class="n">nlams</span><span class="p">,</span> <span class="n">validation</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeller</span><span class="o">.</span><span class="n">check_labeller</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="o">**</span><span class="n">tester_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataManager.checklam_all">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.checklam_all">[docs]</a>
    <span class="k">def</span> <span class="nf">checklam_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lams</span><span class="p">,</span> <span class="n">truth_label_fn</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Labels sets of quartic potential coefficients with True </span>
<span class="sd">        (for bounded from below) or False (not bounded from below).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lams : np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array of quartic coefficients of the potential. </span>
<span class="sd">            Each entry along the 0 axis corresponds to a single set of </span>
<span class="sd">            quartic potential coefficients specifying a potential </span>
<span class="sd">            function.</span>

<span class="sd">        truth_label_fn : callable, optional</span>
<span class="sd">            Must take a 1-D NumPy array representing a single set of </span>
<span class="sd">            quartic coefficients and return a Boolean True if the </span>
<span class="sd">            potential they describe is bounded from below, False </span>
<span class="sd">            otherwise. If this argument is specified, the method </span>
<span class="sd">            will use this callable to label lams instead of the labeller </span>
<span class="sd">            class. This is used in specific instances when a fast symbolic </span>
<span class="sd">            expression for the bounded-from-below constraints is known, </span>
<span class="sd">            and the performance of the classifier training loop can be </span>
<span class="sd">            evaluated in the absence of noise due to the approximate </span>
<span class="sd">            labeller. Obviously the use case of the classifier is for </span>
<span class="sd">            potentials where such a symbolic expression is NOT known, </span>
<span class="sd">            so the real-world model building usefulness of this option </span>
<span class="sd">            is limited.</span>

<span class="sd">        label_kwargs : dict, optional</span>
<span class="sd">            If these are specified, the oracle will use the keyword </span>
<span class="sd">            arguments given here instead of the keyword arguments </span>
<span class="sd">            specified in the DataManager constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array(bool)</span>
<span class="sd">            A Boolean NumPy array of labels for each set of coefficients </span>
<span class="sd">            in lams.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">truth_label_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">truth_label_fn</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">lams</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labeller</span><span class="o">.</span><span class="n">do_labelling</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">label_kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="DataManager.create_data">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.create_data">[docs]</a>
    <span class="k">def</span> <span class="nf">create_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lams</span><span class="p">,</span> <span class="n">truth_label_fn</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an unlabelled 2-D NumPy array of sets of quartic </span>
<span class="sd">        coefficients, label them and return an np_data object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lams : np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array of quartic coefficients of the potential. </span>
<span class="sd">            Each entry along the 0 axis corresponds to a single set of </span>
<span class="sd">            quartic potential coefficients specifying a </span>
<span class="sd">            potential function.</span>

<span class="sd">        truth_label_fn : callable, optional</span>
<span class="sd">            Must take a 1-D NumPy array representing a single set of </span>
<span class="sd">            quartic coefficients and return a Boolean True if the </span>
<span class="sd">            potential they describe is bounded from below, False </span>
<span class="sd">            otherwise. If this argument is specified, the method will use </span>
<span class="sd">            this callable to label lams instead of the labeller class. </span>
<span class="sd">            This is used in specific instances when a fast symbolic </span>
<span class="sd">            expression for the bounded-from-below constraints is known, </span>
<span class="sd">            and the performance of the classifier training loop can be </span>
<span class="sd">            evaluated in the absence of noise due to the approximate </span>
<span class="sd">            oracle. Obviously the use case of the classifier is for </span>
<span class="sd">            potentials where such a symbolic expression is NOT known, </span>
<span class="sd">            so the real-world model building usefulness of this option </span>
<span class="sd">            is limited.</span>

<span class="sd">        label_kwargs : dict, optional</span>
<span class="sd">            If these are specified, the oracle will use the keyword </span>
<span class="sd">            arguments given here instead of the keyword arguments </span>
<span class="sd">            specified in the DataManager constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np_data</span>
<span class="sd">            An np_data object representing the labelled contents of the </span>
<span class="sd">            input array lams.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checklam_all</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">truth_label_fn</span><span class="p">,</span> <span class="n">label_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np_data</span><span class="p">(</span><span class="n">lams</span><span class="p">[</span><span class="n">res</span><span class="p">],</span> <span class="n">lams</span><span class="p">[</span><span class="o">~</span><span class="n">res</span><span class="p">])</span></div>


<div class="viewcode-block" id="DataManager.create_random_data">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.create_random_data">[docs]</a>
    <span class="k">def</span> <span class="nf">create_random_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlams</span><span class="p">,</span> <span class="n">validation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">truth_label_fn</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a random sample of Cartesian lambda coefficients and </span>
<span class="sd">        labels them, then storing the results in an np_data object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nlams : int</span>
<span class="sd">            The number of sets of quartic potential coefficients to </span>
<span class="sd">            generate.</span>

<span class="sd">        validation : bool, default=False</span>
<span class="sd">            If True, use the validation random number generator to </span>
<span class="sd">            generate the random coefficients. If False, use the training </span>
<span class="sd">            random number generator.</span>

<span class="sd">        truth_label_fn : callable, optional</span>
<span class="sd">            Must take a 1-D NumPy array representing a single set of </span>
<span class="sd">            quartic coefficients and return a Boolean True if the </span>
<span class="sd">            potential they describe is bounded from below, False </span>
<span class="sd">            otherwise. If this argument is specified, the method will use </span>
<span class="sd">            this callable to label lams instead of the labeller class. </span>
<span class="sd">            This is used in specific instances when a fast symbolic </span>
<span class="sd">            expression for the bounded-from-below constraints is known, </span>
<span class="sd">            and the performance of the classifier training loop can be </span>
<span class="sd">            evaluated in the absence of noise due to the approximate </span>
<span class="sd">            labeller. Obviously the use case of the classifier is for </span>
<span class="sd">            potentials where such a symbolic expression is NOT known, </span>
<span class="sd">            so the real-world model building usefulness of this option </span>
<span class="sd">            is limited.</span>

<span class="sd">        label_kwargs : dict, optional</span>
<span class="sd">            If these are specified, the oracle will use the keyword </span>
<span class="sd">            arguments given here instead of the keyword arguments </span>
<span class="sd">            specified in the DataManager constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np_data</span>
<span class="sd">            An np_data object that represents the labelled sets of </span>
<span class="sd">            quartic coefficients that was randomly generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_random_lambdas</span><span class="p">(</span><span class="n">nlams</span><span class="p">,</span> <span class="n">validation</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_data</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">truth_label_fn</span><span class="p">,</span> <span class="n">label_kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="DataManager.check_accuracy_with_better_labeller">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.check_accuracy_with_better_labeller">[docs]</a>
    <span class="k">def</span> <span class="nf">check_accuracy_with_better_labeller</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">label_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A method for evaluating the accuracy of a labeller which is </span>
<span class="sd">        capable of mislabelling some False points as True, like the </span>
<span class="sd">        default oracle, which is based on global minimization of the </span>
<span class="sd">        quartic part of the potential.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        in_data : np_data</span>
<span class="sd">            An np_data object, labelled with an oracle that can </span>
<span class="sd">            mislabel some False points as True (but not the reverse).</span>

<span class="sd">        label_kwargs : dict</span>
<span class="sd">            A dictionary which specifies the keyword arguments for the </span>
<span class="sd">            oracle, which must be selected to yield significantly more </span>
<span class="sd">            accurate labels than the ones specified by in_data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The precision (fraction of positively labelled points that </span>
<span class="sd">            are true positives) of the oracle which originally labelled </span>
<span class="sd">            in_data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lams</span> <span class="o">=</span> <span class="n">in_data</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checklam_all</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">label_kwargs</span> <span class="o">=</span> <span class="n">label_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="o">~</span><span class="n">labels</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">lams</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataManager.balance_array">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.balance_array">[docs]</a>
    <span class="k">def</span> <span class="nf">balance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an np_data object that has more negative (not </span>
<span class="sd">        bounded-from-below) points than positives (bounded-from-below), </span>
<span class="sd">        rebalance data to include new positive points generated by </span>
<span class="sd">        leveraging the convexity of the space of bounded-from-below points. </span>
<span class="sd">        If there are as many or more positive points as negative points </span>
<span class="sd">        in the np_data object, leaves the np_data object unmodified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np_data</span>
<span class="sd">            The np_data object that has many more negatively-labelled </span>
<span class="sd">            points (that is, points which are not bounded-from-below) </span>
<span class="sd">            than positives.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the positive and negative data sets.</span>
        <span class="n">lam_pos</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">lam_neg</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">neg</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lam_pos</span><span class="p">)</span>
        <span class="n">neg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lam_neg</span><span class="p">)</span>

        <span class="c1"># If there are no members of one label, or there are an exactly </span>
        <span class="c1"># equal number of members of both labels, or there are already </span>
        <span class="c1"># more positive points than negative points, do nothing.</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">neg</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">neg</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">neg</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="c1"># Generate new points from the positive points that are already </span>
        <span class="c1"># in the data.</span>
        <span class="n">new_lams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_new_positives</span><span class="p">(</span><span class="n">lam_pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np_data</span><span class="p">(</span><span class="n">new_lams</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>

        <span class="c1"># append new data to the np_data object data.</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append_data</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_create_new_positives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lams</span><span class="p">,</span> <span class="n">nlams</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates new bounded-from-below points from existing known </span>
<span class="sd">        ones. Called by balance_array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lams : np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array of quartic coefficients of the potential. </span>
<span class="sd">            Each entry along the 0 axis corresponds to a single set of </span>
<span class="sd">            quartic potential coefficients specifying a potential function.</span>
<span class="sd">            Important that all elements of lams are bounded-from-below.</span>

<span class="sd">        nlams : int</span>
<span class="sd">            The number of new points to generate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array representing nlams sets of new quartic </span>
<span class="sd">            coefficients which are bounded-from-below, since they are </span>
<span class="sd">            sampled along line segments between existing </span>
<span class="sd">            bounded-from-below points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nlams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_len</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_lams</span><span class="p">)):</span>
            <span class="n">pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
            <span class="n">new_lams</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">new_lams</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_lams</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
<div class="viewcode-block" id="DataManager.create_dataset">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.create_dataset">[docs]</a>
    <span class="k">def</span> <span class="nf">create_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">validation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an np_data object, creates a Tensorflow dataset object </span>
<span class="sd">        for training.</span>

<span class="sd">        Paramaters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : np_data</span>

<span class="sd">        validation : bool, default=False</span>
<span class="sd">            If True, don&#39;t shuffle the dataset. Useful for keeping track </span>
<span class="sd">            of agreement on the validation set for the model after </span>
<span class="sd">            successive active learning rounds.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tf.data.Dataset</span>
<span class="sd">            This dataset is NOT batched, but is randomly shuffled on the </span>
<span class="sd">            CPU. To use for training, it is necessary to batch the dataset </span>
<span class="sd">            object with tf.data.Dataset&#39;s batch method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Retrieve the members of the np_data object.</span>
        <span class="n">lam_pos</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">lam_neg</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">neg</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lam_pos</span><span class="p">)</span>
        <span class="n">neg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lam_neg</span><span class="p">)</span>

        <span class="c1"># Create NumPy arrays of the quartic coefficient sets (lams) </span>
        <span class="c1"># and their labels (labs).</span>
        <span class="n">lams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">lam_pos</span><span class="p">,</span> <span class="n">lam_neg</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">neg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Shuffle the order of lams and labs.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">validation</span><span class="p">:</span>
            <span class="n">shuff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labs</span><span class="p">))</span>
            <span class="n">lams</span> <span class="o">=</span> <span class="n">lams</span><span class="p">[</span><span class="n">shuff</span><span class="p">]</span>
            <span class="n">labs</span> <span class="o">=</span> <span class="n">labs</span><span class="p">[</span><span class="n">shuff</span><span class="p">]</span>
        <span class="c1"># Return the tf.data.Dataset object created from the coefficient </span>
        <span class="c1"># sets and their labels.</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">((</span><span class="n">lams</span><span class="p">,</span> <span class="n">labs</span><span class="p">))</span></div>


<div class="viewcode-block" id="DataManager.generate_L">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Data_Manager.DataManager.generate_L">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_L</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nL</span><span class="p">,</span> <span class="n">lams</span><span class="p">,</span> <span class="n">hop_dist</span><span class="p">,</span> <span class="n">probs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rand_fraction</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Randomly generate a sample of new points in the vicinity of </span>
<span class="sd">        some existing points. Given some set of existing points, samples </span>
<span class="sd">        new points by making random hops of an angle given by a draw from </span>
<span class="sd">        a normal distribution in a random direction along the </span>
<span class="sd">        unit hypersphere in quartic coefficient space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nL : int</span>
<span class="sd">            The number of new sets of quartic coefficients to generate.</span>

<span class="sd">        lams : np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array representing sets of quartic potential </span>
<span class="sd">            coefficients. New points will be sampled in the vicinity </span>
<span class="sd">            of these.</span>

<span class="sd">        hop_dist : float</span>
<span class="sd">            The distance scale for sampling around the coefficients in </span>
<span class="sd">            lams. Newly-generated points are taken from input points </span>
<span class="sd">            by randomly rotating points in lams by an angle taken from </span>
<span class="sd">            a normal distribution with standard deviation hop_dist.</span>

<span class="sd">        probs : np.array(np.float32), optional</span>
<span class="sd">            A 1-D NumPy array, should be an array of nonnegative floats </span>
<span class="sd">            which sum to 1, representing the probability of the function </span>
<span class="sd">            selecting each index of lams to generate new points around. </span>
<span class="sd">            If not specified, a uniform selection probability for all </span>
<span class="sd">            points in lams is used.</span>

<span class="sd">        rand_fraction : float, optional</span>
<span class="sd">            Must be a non-negative float between 0 and 1. If specified, </span>
<span class="sd">            then the method will sample that fraction of its points as </span>
<span class="sd">            uniformly distributed draws from the surface of the unit </span>
<span class="sd">            hypersphere in quartic coefficient space, instead of sampling </span>
<span class="sd">            in the vicinity of points in lams. If not specified, all </span>
<span class="sd">            generated points will be sampled in the vicinity of points </span>
<span class="sd">            in lams.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array(np.float32, np.float32)</span>
<span class="sd">            A 2-D NumPy array representing a list of sets of quartic </span>
<span class="sd">            coefficients for the potential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">len_rands</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">nL</span><span class="o">*</span><span class="n">rand_fraction</span><span class="p">))</span>
        <span class="c1">#Create a list of random draws from cart_lams</span>
        <span class="n">picked_lams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">lams</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nL</span> <span class="o">-</span> <span class="n">len_rands</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">probs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1">#Generate an ensemble of random unit vectors that are orthogonal to picked_lams</span>
        <span class="n">orth_rands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_random_lambdas</span><span class="p">(</span><span class="n">nL</span><span class="o">-</span><span class="n">len_rands</span><span class="p">)</span>
        <span class="n">orth_rands</span> <span class="o">=</span> <span class="p">(</span><span class="n">orth_rands</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">orth_rands</span> <span class="o">*</span> <span class="n">picked_lams</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">picked_lams</span><span class="p">)</span>
        <span class="n">orth_rands</span> <span class="o">=</span> <span class="p">(</span><span class="n">orth_rands</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">orth_rands</span> <span class="o">*</span> <span class="n">orth_rands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1">#Create a list of random rotation angles to use here.</span>
        <span class="n">rot_rands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">hop_dist</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nL</span><span class="o">-</span><span class="n">len_rands</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        
        <span class="c1">#Rotate picked_lams in the direction of orth_rands by a random angle.</span>
        <span class="n">L_array</span> <span class="o">=</span> <span class="n">orth_rands</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rot_rands</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">+</span> <span class="n">picked_lams</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rot_rands</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
 
        <span class="k">if</span><span class="p">(</span><span class="n">len_rands</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">L_array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rand_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_random_lambdas</span><span class="p">(</span><span class="n">len_rands</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">L_array</span><span class="p">,</span> <span class="n">rand_array</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">bfbrain</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial and User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">BFBrain</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, George Wojcik.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>
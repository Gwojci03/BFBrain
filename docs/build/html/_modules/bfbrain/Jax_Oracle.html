<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bfbrain.Jax_Oracle &#8212; bfbrain 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for bfbrain.Jax_Oracle</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;The code in this module contains BFBrain&#39;s default algorithm for </span>
<span class="sd">labelling if a point is bounded from below. It is designed to work with </span>
<span class="sd">the methods in Active_Learning.py. The fundamental strategy of this </span>
<span class="sd">labelling method is to take a quartic part of the potential function with </span>
<span class="sd">fixed quartic coefficients, and attempt many consecutive local </span>
<span class="sd">optimizations with respect to the scalar vev with random initial starting </span>
<span class="sd">points. If it can find a point where the potential is negative, it will </span>
<span class="sd">label the set of quartic coefficients as not bounded from below, while </span>
<span class="sd">if after some user-specified number of local minimization iterations the </span>
<span class="sd">found minima are always positive, the set will be labelled as bounded </span>
<span class="sd">from below.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">random</span> <span class="k">as</span> <span class="n">jrandom</span>
<span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jnp</span>
<span class="kn">import</span> <span class="nn">jax.scipy</span> <span class="k">as</span> <span class="nn">jsp</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span> 
<span class="kn">from</span> <span class="nn">bfbrain.Hypersphere_Formulas</span> <span class="kn">import</span> <span class="n">jax_convert_to_polar</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="kn">import</span> <span class="nn">jaxopt</span>
<span class="kn">import</span> <span class="nn">os</span>


<span class="c1">#This line forces Jax to only grab memory from the GPU as it needs it-- </span>
<span class="c1">#otherwise it will by default reserve 90% of the available GPU memory and leave Tensorflow to live on scraps. </span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;XLA_PYTHON_CLIENT_PREALLOCATE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;false&#39;</span>

<div class="viewcode-block" id="take_step">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Jax_Oracle.take_step">[docs]</a>
<span class="k">def</span> <span class="nf">take_step</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">polar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tuple of phi, key (in that order) after randomly </span>
<span class="sd">    generating phi as a vev point on the unit hypersphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x0 : jnp.array(jnp.float32)</span>
<span class="sd">        A Jax NumPy array that tells the function what shape the vev input </span>
<span class="sd">        arrays should be.</span>

<span class="sd">    key : Jax PRNGGKey</span>
<span class="sd">        A key object used to generate random numbers in Jax. Will be </span>
<span class="sd">        consumed over the running of the function and a new key will be </span>
<span class="sd">        returned.</span>

<span class="sd">    polar : bool</span>
<span class="sd">        A flag denoting whether the labeller should use Cartesian </span>
<span class="sd">        coordinates for the vev (False) or convert them into polar </span>
<span class="sd">        coordinates on the unit hypersphere (True).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rand_phi : jnp.array(jnp.float32).</span>
<span class="sd">        A 1-D Jax Numpy array representing a single point in vev space.</span>

<span class="sd">    new_key : Jax PRNGKey</span>
<span class="sd">        A key object used to generate random numbers in Jax. Supplied to </span>
<span class="sd">        replace the consumed key.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate two new keys from key: subkey to be consumed to generate a </span>
    <span class="c1"># random vev configuration and new_key to pass back for future random </span>
    <span class="c1"># number generation.</span>
    <span class="n">new_key</span><span class="p">,</span> <span class="n">subkey</span> <span class="o">=</span> <span class="n">jrandom</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="c1"># Generate a random vev configuration on the phi_len-dimensional unit hypersphere.</span>
    <span class="n">rand_phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">jrandom</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">subkey</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x0</span><span class="p">)))</span>
    <span class="n">rand_phi</span> <span class="o">=</span> <span class="n">rand_phi</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rand_phi</span><span class="p">)</span>
    <span class="c1"># If the minimizer is using polar coordinates, convert rand_phi </span>
    <span class="c1"># to polar coordinates. Otherwise simply return rand_phi (and new_key).</span>
    <span class="k">if</span><span class="p">(</span><span class="n">polar</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">jax_convert_to_polar</span><span class="p">(</span><span class="n">rand_phi</span><span class="p">),</span> <span class="n">new_key</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rand_phi</span><span class="p">,</span> <span class="n">new_key</span></div>


<div class="viewcode-block" id="run_one_step">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Jax_Oracle.run_one_step">[docs]</a>
<span class="k">def</span> <span class="nf">run_one_step</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">minimizer</span><span class="p">,</span> <span class="n">stepper</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">polar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Takes a single local minimization step. This consists of randomly </span>
<span class="sd">    generating a starting point, running the local minimizer from that </span>
<span class="sd">    starting point, and extracting the potential value after minimization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    key : Jax PRNGKey</span>
<span class="sd">        A key object used to generate random numbers in Jax. Will be </span>
<span class="sd">        consumed over the running of the function and a new key will be </span>
<span class="sd">        returned.</span>

<span class="sd">    minimizer : JaxOpt Projected Gradient optimizer object.</span>

<span class="sd">    stepper : callable</span>
<span class="sd">        The function take_step, wrapped to require only a PRNGKey object </span>
<span class="sd">        as input.</span>

<span class="sd">    lam : jnp.array(jnp.float32)</span>
<span class="sd">        A 1-D Jax Numpy array representing a set of quartic coefficients </span>
<span class="sd">        in the scalar potential.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    energy_after_quench : jnp.float32</span>
<span class="sd">        The minimum value of the potential found by minimizer after </span>
<span class="sd">        starting from a random starting position generated with key.</span>

<span class="sd">    new_key : Jax PRNGKey</span>
<span class="sd">        A key object used to generate random numbers in Jax. Supplied to </span>
<span class="sd">        replace the consumed key.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate an initial position for the minimizer to use from the </span>
    <span class="c1"># function stepper. This will also consume the PRNG key and </span>
    <span class="c1"># necessitate acquiring a new one.</span>
    <span class="n">x_after_step</span><span class="p">,</span> <span class="n">new_key</span> <span class="o">=</span> <span class="n">stepper</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">)</span>
    <span class="c1"># Run the minimizer from the point x_after_step. The arguments </span>
    <span class="c1"># for the bounds on variables in the minimizer depend on whether </span>
    <span class="c1"># the minimizer is using polar coordinates or not.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">polar</span><span class="p">):</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x_after_step</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">ub</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span>
        <span class="n">minres</span> <span class="o">=</span> <span class="n">minimizer</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">x_after_step</span><span class="p">,</span> <span class="n">hyperparams_proj</span> <span class="o">=</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x_after_step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ub</span><span class="p">),</span> <span class="n">lam</span> <span class="o">=</span> <span class="n">lam</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">minres</span> <span class="o">=</span> <span class="n">minimizer</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">x_after_step</span><span class="p">,</span> <span class="n">hyperparams_proj</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">lam</span> <span class="o">=</span> <span class="n">lam</span><span class="p">)</span>
    <span class="c1"># Compute the value of the quartic part of the potential at the </span>
    <span class="c1"># minimum.</span>
    <span class="n">energy_after_quench</span> <span class="o">=</span> <span class="n">minimizer</span><span class="o">.</span><span class="n">fun</span><span class="p">(</span><span class="n">minres</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lam</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">energy_after_quench</span><span class="p">,</span> <span class="n">new_key</span></div>



<div class="viewcode-block" id="jax_basinhopping">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Jax_Oracle.jax_basinhopping">[docs]</a>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">jax_basinhopping</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">rng_key</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">minimizer</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">polar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Iterate over run_one_step a large number of times.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lam : jnp.array(jnp.float32)</span>
<span class="sd">        A 1-D Jax Numpy array representing a set of quartic coefficients </span>
<span class="sd">        in the scalar potential.</span>
<span class="sd">        </span>
<span class="sd">    rng_key : Jax PRNGKey</span>
<span class="sd">        Used to generate random numbers.</span>

<span class="sd">    x0 : jnp.array(jnp.float32)</span>
<span class="sd">        A Jax NumPy array that tells the function what shape the vev input </span>
<span class="sd">        arrays should be.</span>

<span class="sd">    minimizer : JaxOpt Projected Gradient optimizer object.</span>

<span class="sd">    niter : int</span>
<span class="sd">        The maximum number of run_one_step iterations to perform in an </span>
<span class="sd">        attempt to find a negative local minimum of the potential.</span>

<span class="sd">    polar : bool</span>
<span class="sd">        A flag denoting whether the labeller should use Cartesian </span>
<span class="sd">        coordinates for the vev (False) or convert them into polar </span>
<span class="sd">        coordinates on the phi_len-dimensional unit hypersphere (True).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_min_energy: jnp.float32</span>
<span class="sd">        The smallest local minimum that the optimizer found after its </span>
<span class="sd">        iterations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define the run_step method from run_one_step, specifying various arguments.</span>
    <span class="n">run_step</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">run_one_step</span><span class="p">,</span> <span class="n">minimizer</span><span class="o">=</span><span class="n">minimizer</span><span class="p">,</span> <span class="n">stepper</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">take_step</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">polar</span> <span class="o">=</span> <span class="n">polar</span><span class="p">),</span> <span class="n">lam</span><span class="o">=</span><span class="n">lam</span><span class="p">,</span> <span class="n">polar</span> <span class="o">=</span> <span class="n">polar</span><span class="p">)</span>
    <span class="c1"># Define a Jax while loop. This loop performs run_one_step repeatedly </span>
    <span class="c1"># and keeps track of the minimum potential value it&#39;s found as min_energy. </span>
    <span class="c1"># If niter iterations have been performed or min_energy is</span>
    <span class="c1"># ever negative, break out of the loop.</span>
    <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="n">carry</span><span class="p">):</span>
        <span class="n">nstep</span><span class="p">,</span> <span class="n">min_energy</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">carry</span>
        <span class="n">trial_energy</span><span class="p">,</span> <span class="n">new_key</span> <span class="o">=</span> <span class="n">run_step</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">new_nstep</span> <span class="o">=</span> <span class="n">nstep</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">min_energy</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">trial_energy</span> <span class="o">&gt;</span> <span class="n">min_energy</span><span class="p">,</span> <span class="n">min_energy</span><span class="p">,</span> <span class="n">trial_energy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_nstep</span><span class="p">,</span> <span class="n">min_energy</span><span class="p">,</span> <span class="n">new_key</span>
    <span class="k">def</span> <span class="nf">cond_fun</span><span class="p">(</span><span class="n">carry</span><span class="p">):</span>
        <span class="n">nstep</span><span class="p">,</span> <span class="n">min_energy</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">carry</span>
        <span class="n">break_cond_negative</span> <span class="o">=</span> <span class="n">min_energy</span> <span class="o">&lt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">break_cond_negative</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nstep</span> <span class="o">&lt;</span> <span class="n">niter</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_min_energy</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">while_loop</span><span class="p">(</span><span class="n">cond_fun</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">rng_key</span><span class="p">))</span>
    <span class="c1"># Return the minimum energy found from the loop.</span>
    <span class="k">return</span> <span class="n">new_min_energy</span></div>


<div class="viewcode-block" id="vectorized_minTest">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Jax_Oracle.vectorized_minTest">[docs]</a>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">vectorized_minTest</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">polar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A vectorized version of jax_basinhopping.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        A Jax Numpy function that returns the quartic potential and its </span>
<span class="sd">        gradient with respect to the vev parameters. This function will </span>
<span class="sd">        be generated by a BFBrain.DataManager object.</span>

<span class="sd">    lam : jnp.array(jnp.float32, jnp.float32)</span>
<span class="sd">        A 2-D Jax NumPy array representing multiple sets of quartic </span>
<span class="sd">        coefficients for the potential.</span>

<span class="sd">    key : Jax PRNGKey</span>

<span class="sd">    x0 : jnp.array(jnp.float32)</span>
<span class="sd">        A Jax NumPy array that informs the function about the shape of </span>
<span class="sd">        the vev input.</span>

<span class="sd">    niter : int</span>
<span class="sd">        The maximum number of local minimization iterations the minimizer </span>
<span class="sd">        should perform for each set of quartic coefficients in lam, </span>
<span class="sd">        searching for a negative minimum potential value.</span>

<span class="sd">    tol : jnp.float32</span>
<span class="sd">        The tolerance for the local minimizer to stop.</span>

<span class="sd">    polar : bool</span>
<span class="sd">        A flag denoting whether the labeller should use Cartesian </span>
<span class="sd">        coordinates for the vev (False) or convert them into polar </span>
<span class="sd">        coordinates on the phi_len-dimensional unit hypersphere (True).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.array(jnp.float32)</span>
<span class="sd">        An array of minimum energy values found for the potentials </span>
<span class="sd">        specified by the elements of lam.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Print statement to alert user to retracing. Retracing is expensive </span>
    <span class="c1"># and should be minimized.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;recompiling vectorized_minTest...&#39;</span><span class="p">)</span>
    <span class="c1"># Set up a local minimizer based on projected gradient descent, </span>
    <span class="c1"># with slightly different construction depending on whether or not </span>
    <span class="c1"># the solver is using polar coordinates.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">polar</span><span class="p">):</span>
        <span class="n">minimizer</span> <span class="o">=</span> <span class="n">jaxopt</span><span class="o">.</span><span class="n">ProjectedGradient</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">jaxopt</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">projection_box</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">value_and_grad</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">minimizer</span> <span class="o">=</span> <span class="n">jaxopt</span><span class="o">.</span><span class="n">ProjectedGradient</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">jaxopt</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">projection_l2_sphere</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">value_and_grad</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Run jax_basinhopping. The jax.vmap decorator vectorizes this code.</span>
    <span class="k">return</span> <span class="n">jax_basinhopping</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">minimizer</span> <span class="o">=</span> <span class="n">minimizer</span><span class="p">,</span> <span class="n">niter</span> <span class="o">=</span> <span class="n">niter</span><span class="p">,</span> <span class="n">polar</span> <span class="o">=</span> <span class="n">polar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>



<div class="viewcode-block" id="label_func">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Jax_Oracle.label_func">[docs]</a>
<span class="k">def</span> <span class="nf">label_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">niter</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span> <span class="n">cutoff</span> <span class="o">=</span> <span class="mi">150000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The function which interfaces directly with BFBrain.DataManager&#39;s </span>
<span class="sd">    methods for handling oracles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        The Jax Numpy function that returns the quartic part of the </span>
<span class="sd">        potential and the gradient.</span>

<span class="sd">    phi_len : int</span>
<span class="sd">        The number of real parameters necessary to uniquely specify a vev.</span>

<span class="sd">    polar : bool</span>
<span class="sd">        A flag denoting whether the labeller should use Cartesian </span>
<span class="sd">        coordinates for the vev (False) or convert them into polar </span>
<span class="sd">        coordinates on the phi_len-dimensional unit hypersphere (True).</span>

<span class="sd">    rng : np.random.Generator</span>
<span class="sd">        The NumPy random number generator which will generate the initial </span>
<span class="sd">        PRNGKey used by this oracle.</span>

<span class="sd">    lam : np.array(np.float32,np.float32)</span>
<span class="sd">        A 2-D Numpy array of quartic potential coefficients.</span>

<span class="sd">    niter : int, default=100</span>
<span class="sd">        The number of local minimizations to perform on the potential </span>
<span class="sd">        before declaring it to be bounded-from-below.</span>

<span class="sd">    tol : float, default=0.001</span>
<span class="sd">        The tolerance for the local minimizer.</span>

<span class="sd">    cutoff : int, default=150000</span>
<span class="sd">        The maximum size of a batch of coefficient values to pass to the </span>
<span class="sd">        GPU at one time. If lam consists of more sets of coefficient </span>
<span class="sd">        values than this, the method will split it into digestible batches.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array(bool)</span>
<span class="sd">        a 1-D NumPy array of labels for each set of quartic coefficients </span>
<span class="sd">        in lam. Labels False for points where the labeller found a </span>
<span class="sd">        negative local minimum and True otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If the size of lam is below cutoff, transfer the entirety of lam to </span>
    <span class="c1"># the GPU at once and label it.</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">label_func_do_batch</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
    <span class="c1"># Otherwise, split lam into smaller chunks that are guaranteed to have </span>
    <span class="c1"># length smaller than cutoff.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lam_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span><span class="o">//</span><span class="n">cutoff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">out_arr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">in_lam</span> <span class="ow">in</span> <span class="n">lam_arr</span><span class="p">:</span>
            <span class="n">out_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label_func_do_batch</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">in_lam</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">out_arr</span><span class="p">)</span></div>



<div class="viewcode-block" id="label_func_do_batch">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Jax_Oracle.label_func_do_batch">[docs]</a>
<span class="k">def</span> <span class="nf">label_func_do_batch</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The method usedy by label_func to transfer the coefficient data to </span>
<span class="sd">    the GPU and perform the jit-compiled analysis with Jax.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        The Jax Numpy function that returns the quartic part of the </span>
<span class="sd">        potential and the gradient.</span>

<span class="sd">    phi_len : int</span>
<span class="sd">        The number of real parameters necessary to uniquely specify a vev.</span>

<span class="sd">    polar : bool</span>
<span class="sd">        A flag denoting whether the labeller should use Cartesian </span>
<span class="sd">        coordinates for the vev (False) or convert them into polar </span>
<span class="sd">        coordinates on the phi_len-dimensional unit hypersphere (True).</span>

<span class="sd">    rng : np.random.Generator</span>
<span class="sd">        The NumPy random number generator which will generate the initial </span>
<span class="sd">        PRNGKey used by this oracle.</span>

<span class="sd">    lam : np.array(np.float32,np.float32)</span>
<span class="sd">        A 2-D Numpy array of quartic potential coefficients.</span>

<span class="sd">    niter : int</span>
<span class="sd">        The number of local minimizations to perform on the potential </span>
<span class="sd">        before declaring it to be bounded-from-below.</span>

<span class="sd">    tol : float</span>
<span class="sd">        The tolerance for the local minimizer.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array(bool)</span>
<span class="sd">        a 1-D NumPy array of labels for each set of quartic coefficients </span>
<span class="sd">        in lam. Labels False for points where the labeller found a </span>
<span class="sd">        negative local minimum and True otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a Jax random number generation key by randomly generating a 64-bit integer.</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">jrandom</span><span class="o">.</span><span class="n">PRNGKey</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># Split the key into a vector of random keys in order to use each with one point&#39;s minimization problem.</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">jrandom</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">lam</span><span class="p">))</span>
    <span class="c1"># Copy lam into a Jax Numpy array on the GPU.</span>
    <span class="n">jnp_lam</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">phi_len</span><span class="p">)</span>
    <span class="c1"># Use vectorized_minTest in order to label each state.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vectorized_minTest</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">jnp_lam</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">niter</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tol</span><span class="p">),</span> <span class="n">polar</span><span class="p">))</span></div>


<div class="viewcode-block" id="test_labeller">
<a class="viewcode-back" href="../../bfbrain.html#bfbrain.Jax_Oracle.test_labeller">[docs]</a>
<span class="k">def</span> <span class="nf">test_labeller</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">niter</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span> <span class="n">cutoff</span> <span class="o">=</span> <span class="mi">150000</span><span class="p">,</span> <span class="n">niter_step</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">count_success</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A method to test the accuracy of the oracle. Will perform </span>
<span class="sd">    label_func repeatedly for the same 2-D NumPy array of quartic </span>
<span class="sd">    coefficients, but with niter increased each time, until the same </span>
<span class="sd">    labels are returned for for a specified consecutive number of </span>
<span class="sd">    iterations, or some maximum number of labellings has been completed </span>
<span class="sd">    without finding consistent results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        The Jax Numpy function that returns the quartic part of the </span>
<span class="sd">        potential and the gradient.</span>

<span class="sd">    phi_len : int</span>
<span class="sd">        The number of real parameters necessary to uniquely specify a vev.</span>

<span class="sd">    polar : bool</span>
<span class="sd">        A flag denoting whether the labeller should use Cartesian </span>
<span class="sd">        coordinates for the vev (False) or convert them into polar </span>
<span class="sd">        coordinates on the phi_len-dimensional unit hypersphere (True).</span>

<span class="sd">    rng : np.random.Generator</span>
<span class="sd">        The NumPy random number generator which will generate the initial </span>
<span class="sd">        PRNGKey used by this oracle.</span>

<span class="sd">    lam : np.array(np.float32,np.float32)</span>
<span class="sd">        A 2-D Numpy array of quartic potential coefficients.</span>

<span class="sd">    niter : int, default=100</span>
<span class="sd">        The initial number of local minimizations to perform on the </span>
<span class="sd">        potential before declaring it to be bounded-from-below-- this </span>
<span class="sd">        value will be incremented over the running of the method.</span>

<span class="sd">    tol : float, default=0.001</span>
<span class="sd">        The tolerance for the local minimizer.</span>
<span class="sd">    cutoff : int, default=150000</span>
<span class="sd">        The maximum size of a batch of coefficient values to pass to the </span>
<span class="sd">        GPU at one time. If lam consists of more sets of coefficient </span>
<span class="sd">        values than this, the method will split it into digestible batches.</span>

<span class="sd">    niter_step : int, default=50</span>
<span class="sd">        The amount to increment the niter parameter of label_func with </span>
<span class="sd">        each successive attempt at labelling lam.</span>

<span class="sd">    count_success : int, default=5</span>
<span class="sd">        The number of consecutive labelling attempts that must yield </span>
<span class="sd">        identical labels for the function to declare that increasing </span>
<span class="sd">        niter is no longer affecting the results of label_func.</span>

<span class="sd">    max_iter : int, default=20</span>
<span class="sd">        The maximum number of labelling attempts that the method will </span>
<span class="sd">        make. If no consistent results are found before that time, the </span>
<span class="sd">        test ends in failure.</span>

<span class="sd">    verbose : bool, default=False</span>
<span class="sd">        If True, print out statements informing the user of the progress </span>
<span class="sd">        of the method.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The minimum niter parameter such that count_success consecutive </span>
<span class="sd">        attempts to label lam with increasing niter yielded the same </span>
<span class="sd">        label. If max_iter attempts are made without running into </span>
<span class="sd">        count_success consecutive identical label results, -1 is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># An integer to keep track of the number of consecutive iterations with </span>
    <span class="c1"># identical labels.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># A NumPy array to keep track of the latest iteration&#39;s labels.</span>
    <span class="n">current_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lam</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="c1"># The index of the earliest iteration to give the same labels as the </span>
    <span class="c1"># current iteration.</span>
    <span class="n">current_ind</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="c1"># In the loop, repeatedly call label_func. With each loop </span>
        <span class="c1"># iteration, increment niter by niter_step. </span>
        <span class="k">if</span><span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;doing round &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">new_res</span> <span class="o">=</span> <span class="n">label_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">phi_len</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">niter</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">niter_step</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done!&#39;</span><span class="p">)</span>
        <span class="c1"># If the labels produced from this iteration differ at all from </span>
        <span class="c1"># those produced by the previous iteration, reset count and </span>
        <span class="c1"># update current_res, and current_ind.</span>
        <span class="n">is_update</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">current_res</span> <span class="o">!=</span> <span class="n">new_res</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">is_update</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;updating the res array from &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current_res</span><span class="p">[</span><span class="n">current_res</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39; positives to &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_res</span><span class="p">[</span><span class="n">new_res</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39; positives...&#39;</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">current_res</span> <span class="o">=</span> <span class="n">new_res</span>
            <span class="n">current_ind</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1"># If the labels are the same as the previous iteration, </span>
        <span class="c1"># increment count.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># If count_success consecutive iterations have given the same </span>
        <span class="c1"># labels, or it is now impossible for that to occur before </span>
        <span class="c1"># max_iter iterations are completed, break out of the loop.</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">count_success</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">+</span> <span class="n">max_iter</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">count_success</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="c1"># If the function was successful in finding consistent labels, </span>
    <span class="c1"># return the smallest niter value such that consecutive iterations </span>
    <span class="c1"># yielded the same result. If the function was unsuccessful, return -1.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">count_success</span><span class="p">):</span>
        <span class="k">if</span><span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;failed to find consistent results after &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; iterations. Recommend decreasing tol or starting again with niter = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">niter</span> <span class="o">+</span> <span class="n">niter_step</span><span class="o">*</span><span class="p">(</span><span class="n">max_iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found consistent results for niter &gt;= &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">niter</span> <span class="o">+</span> <span class="n">current_ind</span><span class="o">*</span><span class="n">niter_step</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">niter</span> <span class="o">+</span> <span class="n">current_ind</span><span class="o">*</span><span class="n">niter_step</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">bfbrain</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial and User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">BFBrain</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, George Wojcik.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>